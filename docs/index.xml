<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>4afS blog</title>
    <link>https://4afs.github.io/blog/</link>
    <description>Recent content on 4afS blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 09 Dec 2020 00:41:40 +0900</lastBuildDate><atom:link href="https://4afs.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>体重計を作る　～フロントエンド編～</title>
      <link>https://4afs.github.io/blog/posts/plumit-front/</link>
      <pubDate>Wed, 09 Dec 2020 00:41:40 +0900</pubDate>
      
      <guid>https://4afs.github.io/blog/posts/plumit-front/</guid>
      <description>この記事は https://4afs.hatenablog.com/entry/2019/12/22/213703 から移行したものです．
  この記事は大阪工業大学 Advent Calendar 2019の23日目の記事です．
こんにちは，Hibiki(@4afS_)です．
今回は初めてのWebページ作成に挑戦しました．期間が２週間弱ほどしか取れなかったので完成できるか不安でしたが，無事間に合ってよかったです．完成したものは実際にここから，ソースコードはここから見ることができます．
はじめに このプロジェクトはモノ編・バックエンド編・フロントエンド編の３部構成です． 作成に至る経緯などは上の記事をを参照していただけると幸いです．
自己紹介 関西の情報系大学２回生で，普段はHaskell書いたりウォーキング・デッドを見たりしてます． Web周りの経験としては，少しHTMLとCSS，Elmに触れたことがある程度でJavaScriptや他のフレームワークの経験は0です．
開発環境 Angular CLI : 8.3.20
npm : 6.13.2
chart.js : 2.9.3
開発過程 表示したいものを考える 今回は友人の体重を表示するためのものなので，それがひと目でわかるグラフを表示することにします．
デザインを考える はじめからコードを書くのは流石にしんどいと思うので，まずAdobe XDを使ってプロトタイプを作ります．その際にアイコンが欲しくなったので体重計のようなものを簡単にillustratorで作りました． 実際のアイコンとXDで作成したプロトタイプが↓です．
構成を考える Angularはcomponent単位で考えるので，プロトタイプから分割して，Header，大きく文字が書かれたTitle，グラフがあるWeightChart，最後にFooterの構成で作成することにします．また，Httpリクエスト部分はサービスへ分離することにしました．
実際にコーディング コーディング環境は，NeoVim + coc.nvimにTypeScript，Angular，HTMLのLanguageServerを導入して書いていきます．coc.nvimは今すごく気に入ってるプラグインなので，またそれについての記事も書こうと思います．
今回のWebページはPC，スマホどちらからも崩れずに見れるように，知識がないので無理矢理ですがレスポンシブにしていきます．
Header・Footer まずはHeaderとFooterです．ここでは，Angular Materialから提供されているmat-toolbarを使います．使うのはとても簡単で，
&amp;lt;mat-toolbar&amp;gt; &amp;lt;mat-toolbar-row&amp;gt; 要素を列挙する &amp;lt;/mat-toolbar-row&amp;gt; &amp;lt;/mat-toolbar&amp;gt; とするだけでツールバーが作成されます．これを上下においてHeader，Footerとすることにします．
タイトル ここでは文字が大きく表示されるのでフォントにこだわりました．正直どう選べばいいかよくわからなかったので雰囲気で．
グラフ 今回は体重がどのように変化しているかを見ることが目的なので，折れ線グラフを採用します．グラフの描画にはChart.jsを使い，X軸に日付，Y軸に体重を割り当て，量ってない日もわかるように値があるところには丸いポイントをつけます．
完成！ 初めてのWebページ作成で，しかもあまり勉強時間が取れないなかで無事完成までたどり着けてよかったです．間違っているところもたくさんあると思うので，これからWeb系の勉強をしていこうと思います．
おまけ 右上にひっそりいる数字ですが，一応アクセスカウンターです．もともと「あなたは○○人目の訪問者です」をやりたかったんですけど，しっくりこなかったので小さめに表示しました．</description>
    </item>
    
    <item>
      <title>いろいろなデータベースの種類について</title>
      <link>https://4afs.github.io/blog/posts/type-of-databases/</link>
      <pubDate>Wed, 30 Sep 2020 09:38:44 +0900</pubDate>
      
      <guid>https://4afs.github.io/blog/posts/type-of-databases/</guid>
      <description>初めに 先日API開発をしている際に，雑にMySQLを選定してしまいました．本当にこれでいいのか？と疑問に思い調べたので，その内容をまとめておこうと思います．また，それぞれのタイプについての説明のみで，実際にそのタイプが用いられているデータベースの説明をするものではありません．
主なデータベースの種類 データベースの種類はたくさんありますが，ここではその一部を紹介します．
 RDB (Relational Data Base) NoSQL  KVS (キーバリュー型) 列指向型 ドキュメント指向型 グラフ指向型    RDB 概要 現在主流とされているデータベース．複数のテーブルで構成され，個々のテーブルが他のテーブルと関係を持つ．テーブルとは，行と列を持つもので，Excelの表のようなイメージ．
強み  ACID特性を満たすトランザクションにより，データの一貫性が保証される． 正規化によるテーブルの連鎖を用いたデータベースの構築により，追加・削除・更新等の処理コストが低い． SQLの文法を使用できるため，複雑な条件での検索や集計が可能． 一度に大量の処理を実行することができる． 運用実績が豊富なので情報が多い．  弱み  事前にデータの定義をしておく必要があるため，拡張にコストがかかる． データの一貫性を保証することを重視しているため，分散環境には不向き． SQLのオーバーヘッドが大きいため，シンプルな処理での速度はNoSQLと比較すると遅い．  代表的なサービス MySQL : https://www.mysql.com/jp/
PostgreSQL : https://www.postgresql.jp/
SQLite : https://www.sqlite.org/index.html
NoSQL NoSQLはRDBのサブセットで，機能の豊富なRDBから何を省略したかでNoSQLを分類することができると思います．
KVS（キーバリュー型） 概要 名前の通り，キーと値からなるシンプルなデータベース．
特徴  データ構造がシンプルで分割可能なのでスケールアウトが容易． データへのアクセスが高速  列指向型 概要 一般的なRDBは行指向データベースです．行指向データベースでは行1つ1つをひとかたまりのデータとして扱います．そのため，データの追加は行ごとに，検索結果は複数の行として，削除や更新も特定の行を指定して行います．それに対して列指向データベースは，列1つ1つをひとかたまりのデータとして扱います．そのため追加や検索，削除等もすべて列単位で行われます．
特徴  データ列の高速な取得向けに最適化されているため，ビックデータ等の扱いが得意． 必要のないデータ列へのアクセスを行わないので，ディクスI/Oがかなり小さい． 特定の列のみへの処理が主なためスケールアウトが容易．  代表的なサービス Amazon Redshift : https://aws.amazon.com/jp/redshift/</description>
    </item>
    
    <item>
      <title>「Go言語による並行処理」の1章を読んで</title>
      <link>https://4afs.github.io/blog/posts/concurrency-in-go-1/</link>
      <pubDate>Thu, 16 Jan 2020 19:42:14 +0900</pubDate>
      
      <guid>https://4afs.github.io/blog/posts/concurrency-in-go-1/</guid>
      <description>「Go言語による並行処理」の1章を読んで得たこと，わかったこと，わからなかったことについて書こうと思う。
並行処理がなぜむずかしいのか この理由の主は，競合状態・アトミック性・メモリアクセス同期．
競合状態は，並列にあるデータへ処理をすることによって同期的に実行しているプロセスの結果にばらつきを生じる状態のこと．これは複数の動作が意図している順番に実行されないことによって起こる．
アトミック性は今回この本で初めて見た単語だったので少し調べてみた．アトミックであるとはどういうことかから引用すると，
 ある操作がアトミックであるといえば、その操作は分かつことができないという意味
 ということらしい．これがなぜ並行処理と関わるのか．このアトミック性には割り込み・中断不可の意味もあり，その点で並行処理と関係しているっぽい．
また，アトミック性が登場する1.2.2ではコンテキストについても言及されている．私の中では環境と置き換えて読んでいる．本の中でも「コンテキストは操作がアトミックであると考えられる範囲」とあるのと，私が個人的に論理学の議題領域のようなに感じたからだ．始めなので置き換えているが，読み進めるうちにコンテキストと読むようにしていきたい．
最後にメモリアクセス同期．これはまだあまりしっくりきていないが，今の認識ではメモリへのアクセスを同期して排他的なアクセスのみにすることだと考えている．
メモリアクセス同期の際に起こる問題 この際に発生する問題として，デッドロック・ライブロック・リソースの枯渇が上がっている．
デッドロックは定番で，複数の並行なプロセスが互いの処理も待ち合って進まない様子のことだ．
ライブロックは今回初めて聞いた問題だった．これはデッドロックを回避するための処理が同じタイミングで動作してしまい，ずっと譲り合いをしている状況だ．本の例えでは「廊下で誰かとすれ違う際，相手が避けた方向に自分も避けてしまい，またそれを繰り返すことで進まなくなってしまう状態を想像すればライブロックを理解できる．」と書いていて，私はこの例で理解することができた．
最後にリソースの枯渇．これは複数プロセスがある際に，一つのプロセスがリソースを食い尽くしてしまっているがために他のプロセスが十分にリソースを確保できなくなってしまうことだ．理論的にはわかるのだが，実際にサンプルコードを実行してみるとよくわからなかった．本には「LockやUnlockが遅いから，というのは違う」と書いてるのだが，実際にpolite workerとgreedy workerを別々で実行するとpolite workerの方が明らかに処理回数が少なかったので，この件に関してはまた読み進めたらわかるだろうということで今回はスルーしておく．
最後に 私自身並行処理はほぼ未経験なのでここまで初歩から説明がされていてとても助けられた．この章の最後に「並行処理で起こる問題へGoからの正しいアプローチ」と書かれており，続きがとても気になった．また次章も記事にできたらと思う．</description>
    </item>
    
  </channel>
</rss>
