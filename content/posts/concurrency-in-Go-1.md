+++ 
draft = false 
date = 2020-01-16T19:42:14+09:00
title = "「Go言語による並行処理」の1章を読んで"
description = ""
slug = "" 
tags = ["programming", "golang", "concurrency"]
categories = []
externalLink = ""
series = []
+++

「Go言語による並行処理」の1章を読んで得たこと，わかったこと，わからなかったことについて書こうと思う。

### 並行処理がなぜむずかしいのか
この理由の主は，**競合状態**・**アトミック性**・**メモリアクセス同期**．

**競合状態**は，並列にあるデータへ処理をすることによって同期的に実行しているプロセスの結果にばらつきを生じる状態のこと．これは複数の動作が意図している順番に実行されないことによって起こる．

**アトミック性**は今回この本で初めて見た単語だったので少し調べてみた．[アトミックであるとはどういうことか](https://kumikomiya.com/what-does-it-mean-to-be-atomic/)から引用すると，

> ある操作がアトミックであるといえば、その操作は分かつことができないという意味

ということらしい．これがなぜ並行処理と関わるのか．このアトミック性には割り込み・中断不可の意味もあり，その点で並行処理と関係しているっぽい．

また，アトミック性が登場する1.2.2では**コンテキスト**についても言及されている．私の中では**環境**と置き換えて読んでいる．本の中でも「コンテキストは操作がアトミックであると考えられる範囲」とあるのと，私が個人的に論理学の議題領域のようなに感じたからだ．始めなので置き換えているが，読み進めるうちにコンテキストと読むようにしていきたい．

最後に**メモリアクセス同期**．これはまだあまりしっくりきていないが，今の認識ではメモリへのアクセスを同期して排他的なアクセスのみにすることだと考えている．

### メモリアクセス同期の際に起こる問題
この際に発生する問題として，**デッドロック**・**ライブロック**・**リソースの枯渇**が上がっている．

**デッドロック**は定番で，複数の並行なプロセスが互いの処理も待ち合って進まない様子のことだ．

**ライブロック**は今回初めて聞いた問題だった．これはデッドロックを回避するための処理が同じタイミングで動作してしまい，ずっと譲り合いをしている状況だ．本の例えでは「廊下で誰かとすれ違う際，相手が避けた方向に自分も避けてしまい，またそれを繰り返すことで進まなくなってしまう状態を想像すればライブロックを理解できる．」と書いていて，私はこの例で理解することができた．

最後に**リソースの枯渇**．これは複数プロセスがある際に，一つのプロセスがリソースを食い尽くしてしまっているがために他のプロセスが十分にリソースを確保できなくなってしまうことだ．理論的にはわかるのだが，実際にサンプルコードを実行してみるとよくわからなかった．本には「LockやUnlockが遅いから，というのは違う」と書いてるのだが，実際にpolite workerとgreedy workerを別々で実行するとpolite workerの方が明らかに処理回数が少なかったので，この件に関してはまた読み進めたらわかるだろうということで今回はスルーしておく．

### 最後に
私自身並行処理はほぼ未経験なのでここまで初歩から説明がされていてとても助けられた．この章の最後に「並行処理で起こる問題へGoからの正しいアプローチ」と書かれており，続きがとても気になった．また次章も記事にできたらと思う．
